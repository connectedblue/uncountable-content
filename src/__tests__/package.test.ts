/**
 * @fileoverview Package Command Tests
 * 
 * Comprehensive tests for the npm run package command functionality
 * including content validation, archive creation, and cleanup.
 */

import { jest } from '@jest/globals';
import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';

// Mock external dependencies
jest.mock('fs/promises');
jest.mock('child_process');

const mockFs = fs as jest.Mocked<typeof fs>;
const mockExecSync = execSync as jest.MockedFunction<typeof execSync>;

describe('Package Command Tests', () => {
  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Content Change Detection', () => {
    it('should detect content changes using git status with untracked files', async () => {
      // Mock git status to show changes including untracked files
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status --porcelain -u content/')) {
          return 'M content/diary-123.md\nA content/thoughts-456.md\n?? content/new-untracked.md\n';
        }
        return Buffer.from('');
      });

      // Simulate git status check
      const gitStatus = execSync('git status --porcelain -u content/', { encoding: 'utf8' });
      const hasChanges = gitStatus.trim() !== '';

      expect(hasChanges).toBe(true);
      expect(mockExecSync).toHaveBeenCalledWith('git status --porcelain -u content/', { encoding: 'utf8' });
    });

    it('should skip packaging when no content changes detected', async () => {
      // Mock git status to show no changes
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status --porcelain -u content/')) {
          return '';
        }
        return Buffer.from('');
      });

      const gitStatus = execSync('git status --porcelain -u content/', { encoding: 'utf8' });
      const hasChanges = gitStatus.trim() !== '';

      expect(hasChanges).toBe(false);
    });

    it('should detect untracked files in content directory', async () => {
      // Mock git status to show only untracked files
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status --porcelain -u content/')) {
          return '?? content/new-untracked-file.md\n?? content/media/untracked-image.md\n';
        }
        return Buffer.from('');
      });

      const gitStatus = execSync('git status --porcelain -u content/', { encoding: 'utf8' });
      const hasChanges = gitStatus.trim() !== '';

      expect(hasChanges).toBe(true);
      expect(gitStatus).toContain('?? content/new-untracked-file.md');
      expect(gitStatus).toContain('?? content/media/untracked-image.md');
    });

    it('should handle git unavailable gracefully', async () => {
      // Mock git command to throw error
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status')) {
          throw new Error('git: command not found');
        }
        return Buffer.from('');
      });

      expect(() => {
        execSync('git status --porcelain content/', { encoding: 'utf8' });
      }).toThrow('git: command not found');
    });
  });

  describe('Git Integration', () => {
    it('should commit content changes with descriptive message', async () => {
      mockExecSync.mockReturnValue(Buffer.from(''));

      // Mock environment variable
      process.env.npm_package_version = '1.1.0';

      // Simulate git operations
      execSync('git add content/', { stdio: 'inherit' });
      
      const commitMessage = `content: Update WordPress content (2025-07-20)

- Total files: 2044 (1500 posts, 544 media)
- Content size: 15.2 MB
- Auto-generated by wordpress-content-service v1.1.0`;

      execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });
      execSync('git push origin HEAD', { stdio: 'inherit' });

      expect(mockExecSync).toHaveBeenCalledWith('git add content/', { stdio: 'inherit' });
      expect(mockExecSync).toHaveBeenCalledWith(
        expect.stringContaining('git commit -m "content: Update WordPress content'),
        { stdio: 'inherit' }
      );
      expect(mockExecSync).toHaveBeenCalledWith('git push origin HEAD', { stdio: 'inherit' });

      // Clean up
      delete process.env.npm_package_version;
    });

    it('should handle git commit failures gracefully', async () => {
      // Mock git add to succeed but commit to fail
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git add')) {
          return Buffer.from('');
        }
        if (command.includes('git commit')) {
          throw new Error('Nothing to commit');
        }
        return Buffer.from('');
      });

      expect(() => {
        execSync('git add content/', { stdio: 'inherit' });
      }).not.toThrow();

      expect(() => {
        execSync('git commit -m "test"', { stdio: 'inherit' });
      }).toThrow('Nothing to commit');
    });

    it('should handle git push failures gracefully', async () => {
      // Mock git operations - add and commit succeed, push fails
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git add') || command.includes('git commit')) {
          return Buffer.from('');
        }
        if (command.includes('git push')) {
          throw new Error('Failed to push to remote');
        }
        return Buffer.from('');
      });

      expect(() => {
        execSync('git push origin HEAD', { stdio: 'inherit' });
      }).toThrow('Failed to push to remote');
    });
  });

  describe('Content Fetching Integration', () => {
    it('should fetch recent content before checking for changes', async () => {
      // Test the content fetching workflow logic
      const sinceDate = new Date();
      sinceDate.setDate(sinceDate.getDate() - 30);

      // Simulate recent content fetch returning posts
      const recentPosts = [
        { id: 1, title: 'Recent Post 1', modified: '2025-07-15T10:00:00Z' },
        { id: 2, title: 'Recent Post 2', modified: '2025-07-16T15:30:00Z' }
      ];

      // Test that we have recent posts to process
      expect(recentPosts).toHaveLength(2);
      expect(recentPosts[0].title).toBe('Recent Post 1');
    });

    it('should skip packaging when no recent content found and no git changes', async () => {
      // Simulate empty recent content fetch
      const recentPosts: any[] = [];

      // Mock git status showing no changes (including untracked files)
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status --porcelain -u content/')) {
          return '';
        }
        return Buffer.from('');
      });

      const gitStatus = execSync('git status --porcelain -u content/', { encoding: 'utf8' });
      const hasChanges = gitStatus.trim() !== '';

      expect(recentPosts).toHaveLength(0);
      expect(hasChanges).toBe(false);
    });

    it('should proceed with packaging when recent content creates git changes', async () => {
      // Simulate recent content found
      const recentPosts = [
        { id: 1, title: 'New Post', modified: '2025-07-20T10:00:00Z' }
      ];

      // Mock git status showing changes after content fetch (including untracked files)
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('git status --porcelain -u content/')) {
          return 'A content/new-post.md\n?? content/untracked-media.md\n';
        }
        return Buffer.from('');
      });

      const gitStatus = execSync('git status --porcelain -u content/', { encoding: 'utf8' });
      const hasChanges = gitStatus.trim() !== '';

      expect(recentPosts).toHaveLength(1);
      expect(hasChanges).toBe(true);
    });

    it('should handle content fetching errors gracefully', async () => {
      // Simulate API error during content fetch
      const apiError = new Error('API connection failed');

      expect(apiError.message).toBe('API connection failed');
      expect(() => { throw apiError; }).toThrow('API connection failed');
    });
  });

  describe('Content Directory Validation Logic', () => {
    it('should validate content directory existence', async () => {
      // Test the core logic without the CLI wrapper
      
      // Mock fs.access to throw error (directory doesn't exist)
      mockFs.access.mockRejectedValue(new Error('ENOENT'));

      try {
        await mockFs.access('./content');
        throw new Error('Should have thrown');
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
        expect((error as Error).message).toBe('ENOENT');
      }

      expect(mockFs.access).toHaveBeenCalledWith('./content');
    });

    it('should calculate content age correctly', async () => {
      // Test age calculation logic
      const oldDate = new Date(Date.now() - (25 * 60 * 60 * 1000));
      const recentDate = new Date(Date.now() - (1 * 60 * 60 * 1000));
      
      const oldAge = Math.floor((Date.now() - oldDate.getTime()) / (1000 * 60 * 60));
      const recentAge = Math.floor((Date.now() - recentDate.getTime()) / (1000 * 60 * 60));
      
      expect(oldAge).toBeGreaterThanOrEqual(24);
      expect(recentAge).toBeLessThan(24);
    });
  });

  describe('Directory Management Logic', () => {
    it('should handle directory creation operations', async () => {
      mockFs.mkdir.mockResolvedValue(undefined);

      await mockFs.mkdir('./content-cache', { recursive: true });
      await mockFs.mkdir('./archives', { recursive: true });

      expect(mockFs.mkdir).toHaveBeenCalledWith('./content-cache', { recursive: true });
      expect(mockFs.mkdir).toHaveBeenCalledWith('./archives', { recursive: true });
    });

    it('should handle cache directory cleanup', async () => {
      // Mock cache directory with existing files
      mockFs.readdir.mockResolvedValue(['old-file.md', 'old-dir'] as any);
      mockFs.stat.mockImplementation((filePath: any) => {
        if (filePath.includes('old-file.md')) {
          return Promise.resolve({ isDirectory: () => false } as any);
        }
        if (filePath.includes('old-dir')) {
          return Promise.resolve({ isDirectory: () => true } as any);
        }
        return Promise.resolve({ size: 1234567 } as any);
      });
      
      mockFs.unlink.mockResolvedValue(undefined);
      mockFs.rm.mockResolvedValue(undefined);

      // Simulate cleanup logic
      const cacheDir = './content-cache';
      const cacheContents = await mockFs.readdir(cacheDir);
      
      for (const item of cacheContents) {
        const itemPath = path.join(cacheDir, item);
        const stat = await mockFs.stat(itemPath);
        if (stat.isDirectory()) {
          await mockFs.rm(itemPath, { recursive: true });
        } else {
          await mockFs.unlink(itemPath);
        }
      }

      expect(mockFs.readdir).toHaveBeenCalledWith('./content-cache');
      expect(mockFs.unlink).toHaveBeenCalledWith(path.join('./content-cache', 'old-file.md'));
      expect(mockFs.rm).toHaveBeenCalledWith(path.join('./content-cache', 'old-dir'), { recursive: true });
    });
  });

  describe('Content Copy Operations', () => {
    it('should handle content copying command', async () => {
      mockExecSync.mockReturnValue(Buffer.from(''));

      // Simulate copy operation
      execSync('cp -r ./content/* ./content-cache/', { stdio: 'inherit' });

      expect(mockExecSync).toHaveBeenCalledWith(
        'cp -r ./content/* ./content-cache/',
        { stdio: 'inherit' }
      );
    });
  });

  describe('Metadata Generation', () => {
    it('should create correct package metadata structure', async () => {
      mockFs.writeFile.mockResolvedValue(undefined);

      // Mock environment variable
      process.env.npm_package_version = '2.1.0';

      // Simulate metadata creation
      const metadata = {
        created: new Date().toISOString(),
        version: process.env.npm_package_version || '1.0.0',
        sites: [
          {
            site_name: 'My Thoughts',
            wp_url: 'https://thoughts.uncountable.uk',
            root_slug: 'thoughts',
            category_slug: 'thoughts-on',
            tag_slug: 'topic'
          },
          {
            site_name: 'My Diary',
            wp_url: 'https://diary.uncountable.uk',
            root_slug: 'diary',
            category_slug: 'projects',
            tag_slug: 'series'
          }
        ]
      };

      await mockFs.writeFile(
        path.join('./content-cache', 'package-info.json'),
        JSON.stringify(metadata, null, 2)
      );

      expect(mockFs.writeFile).toHaveBeenCalledWith(
        path.join('./content-cache', 'package-info.json'),
        expect.stringContaining('"version": "2.1.0"')
      );

      expect(metadata).toHaveProperty('created');
      expect(metadata).toHaveProperty('version', '2.1.0');
      expect(metadata).toHaveProperty('sites');
      expect(metadata.sites).toHaveLength(2);
      expect(metadata.sites[0]).toHaveProperty('site_name', 'My Thoughts');
      expect(metadata.sites[0]).toHaveProperty('wp_url', 'https://thoughts.uncountable.uk');
      expect(metadata.sites[0]).toHaveProperty('root_slug', 'thoughts');
      expect(metadata.sites[0]).toHaveProperty('category_slug', 'thoughts-on');
      expect(metadata.sites[0]).toHaveProperty('tag_slug', 'topic');

      // Clean up
      delete process.env.npm_package_version;
    });

    it('should use default version when npm_package_version is not set', async () => {
      // Ensure environment variable is not set
      delete process.env.npm_package_version;

      const metadata = {
        created: new Date().toISOString(),
        version: process.env.npm_package_version || '1.0.0',
        sites: []
      };

      expect(metadata.version).toBe('1.0.0');
    });
  });

  describe('Archive Creation', () => {
    it('should create archive with correct timestamp format', async () => {
      // Mock current date
      const mockDate = new Date('2025-07-20T10:30:00Z');
      jest.spyOn(global, 'Date').mockImplementation((() => mockDate) as any);

      mockExecSync.mockReturnValue(Buffer.from(''));

      // Simulate archive creation
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
      const archiveName = `wordpress-content-${timestamp}.tar.gz`;
      const archivePath = path.join('./archives', archiveName);

      execSync(`tar -czf ${archivePath} -C ./content-cache .`, { stdio: 'inherit' });

      expect(archiveName).toBe('wordpress-content-2025-07-20.tar.gz');
      expect(mockExecSync).toHaveBeenCalledWith(
        expect.stringContaining('tar -czf archives/wordpress-content-2025-07-20.tar.gz'),
        { stdio: 'inherit' }
      );
    });
  });

  describe('File Size Formatting', () => {
    it('should format bytes correctly', () => {
      // Test the formatBytes logic
      const formatBytes = (bytes: number): string => {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      };

      expect(formatBytes(0)).toBe('0 Bytes');
      expect(formatBytes(1024)).toBe('1 KB');
      expect(formatBytes(1234567)).toBe('1.18 MB');
      expect(formatBytes(5368709120)).toBe('5 GB');
    });
  });

  describe('Cleanup Operations', () => {
    it('should handle cache directory removal', async () => {
      mockFs.rm.mockResolvedValue(undefined);

      await mockFs.rm('./content-cache', { recursive: true, force: true });

      expect(mockFs.rm).toHaveBeenCalledWith('./content-cache', { 
        recursive: true, 
        force: true 
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle copy command failures', async () => {
      // Mock execSync to throw error during copy
      mockExecSync.mockImplementation(() => {
        throw new Error('Copy failed');
      });

      expect(() => {
        execSync('cp -r ./content/* ./content-cache/', { stdio: 'inherit' });
      }).toThrow('Copy failed');
    });

    it('should handle archive creation failures', async () => {
      // Mock execSync to fail on tar command
      mockExecSync.mockImplementation((command: string): any => {
        if (command.includes('tar -czf')) {
          throw new Error('Archive creation failed');
        }
        return Buffer.from('');
      });

      expect(() => {
        execSync('tar -czf test.tar.gz -C ./content-cache .', { stdio: 'inherit' });
      }).toThrow('Archive creation failed');
    });

    it('should handle filesystem operation failures', async () => {
      // Mock fs operations to fail
      mockFs.mkdir.mockRejectedValue(new Error('Directory creation failed'));
      mockFs.rm.mockRejectedValue(new Error('Cleanup failed'));
      mockFs.writeFile.mockRejectedValue(new Error('Write failed'));

      await expect(mockFs.mkdir('./content-cache', { recursive: true }))
        .rejects.toThrow('Directory creation failed');
      
      await expect(mockFs.rm('./content-cache', { recursive: true, force: true }))
        .rejects.toThrow('Cleanup failed');
      
      await expect(mockFs.writeFile('./test.json', '{}'))
        .rejects.toThrow('Write failed');
    });
  });
});
